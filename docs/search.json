[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Analysis of the behavior of dairy cattle using R",
    "section": "",
    "text": "Preface\n\n\n\n\n\n\nWarning: Under Construction\n\n\n\n\n\nBefore you dive into the content of this guide, we feel it is our responsibility to inform you that it is currently under construction. We strongly recommend postponing your reading until we’ve completed the necessary updates to ensure your learning experience is as valuable as possible.\n\n\n\nWelcome to this online course on “Analysis of the behavior of dairy cattle using R”. This tutorial is divided into two parts, each of which plays a critical role in understanding and applying data-driven insights to the study of dairy cattle behavior, particularly in response to various human interventions, with a focus on enviromental conditions.\nPart 1, “Introduction to R,” provides the foundation for data analysis and visualization. In this section, we will introduce you to R, a powerful programming language and environment for statistical computing and graphics. We will explore the basics of R, from setting up the environment to performing data manipulation and visualization. These skills are essential for conducting the advanced statistical analysis presented in Part 2.\nPart 2, “Statistical Modeling of Dairy Cattle Behavior”, explores the realm of data-driven analysis concerning dairy cattle behavior. You will learn how to collect and preprocess behavioral data, and then apply advanced statistical modeling techniques to understand how climate conditions and other human interventions impact the behavior of dairy cattle.\nThis course is designed to provide elementary skills and knowledge necessary to conduct useful statistical analysis in the context of dairy cattle behavior. Whether you are a scientist, a farmer, a professional or a student, this course will provide you with the tools needed to make informed decisions and contribute to the welfare and productivity of dairy cattle."
  },
  {
    "objectID": "intro.html#the-r-language",
    "href": "intro.html#the-r-language",
    "title": "1  Introduction",
    "section": "1.1 The R Language",
    "text": "1.1 The R Language\nThe R programming language is a powerful tool designed for statistical computing and data analysis. Originating in the early 1990s at the University of Auckland, New Zealand, by Ross Ihaka and Robert Gentleman, R has garnered a dedicated following in the fields of data science, statistics, and data visualization.\nWhat sets R apart is its rich toolkit of statistical and graphical techniques, making it a top choice for researchers, statisticians, data analysts, and data scientists. R offers an extensive collection of packages and libraries tailored to specific data analysis and visualization needs, creating a diverse ecosystem of tools.\nSome important features of R Language:\n\nOpen Source Foundation: R is open-source, fostering a vibrant community of users and developers, driving its continuous improvement.\nData Manipulation Proficiency: R excels in data manipulation with libraries like dplyr and tidyr, simplifying data cleaning and reshaping.\nStatistical Versatility: R offers a wide range of statistical methods, from basic statistics to advanced modeling and hypothesis testing.\nElegant Data Visualization: R is renowned for its data visualization capabilities, with ggplot2 enabling customizable and appealing visualizations.\nExtensibility: R allows users to create and share packages, leading to a rich repository of specialized tools.\nReproducibility Support: R promotes reproducible research through scripting and documentation, enhancing research credibility.\nCommunity Support: R has a thriving community with abundant resources and forums for assistance and collaboration.\nCross-Platform Compatibility: R is available on Windows, macOS, and Linux, ensuring accessibility to a diverse user base."
  },
  {
    "objectID": "intro.html#tidyverse-a-revolution-in-r",
    "href": "intro.html#tidyverse-a-revolution-in-r",
    "title": "1  Introduction",
    "section": "1.2 Tidyverse: A Revolution in R",
    "text": "1.2 Tidyverse: A Revolution in R\nIn recent years, the emergence of tidyverse libraries has brought significant advancements to R, making data manipulation and analysis more straightforward. One notable innovation within the tidyverse is the introduction of pipe operations, marked by |&gt;, which streamline workflows and improve code readability.\nThe pipe operator allows you to chain data manipulation functions, effortlessly passing the output from one function to the next. This creates a more linear and intuitive sequence of operations, reducing the reliance on temporary variables and minimizing nested function calls. The result is code that is more comprehensible and easier to maintain.\nConsider a straightforward example of the pipe operator’s utility in R:\n\nlibrary(tidyverse)\n# Creating a sample data frame\ndata &lt;- data.frame(\n  Name = c(\"Alice\", \"Bob\", \"Charlie\"),\n  Age = c(28, 35, 22)\n)\n\n# Utilizing the pipe operator for data manipulation\nresult &lt;- data |&gt;\n  filter(Age &gt;= 25) |&gt;\n  arrange(desc(Age))\n\nprint(result)\n\n   Name Age\n1   Bob  35\n2 Alice  28\n\n\nIn this instance, we initially filter the rows where Age is greater than or equal to 25 and then arrange the data in descending order of Age. The pipe operator (|&gt;) effortlessly conveys the data frame from one operation to the next, rendering the code more succinct and comprehensible.\nThe pipe operator (|&gt;) elevates code readability by facilitating a natural and intuitive sequence of data manipulation operations. Let’s elucidate this with some examples.\nWithout the Pipe Operator:\nImagine you have a data frame containing a list of products, and you need to perform a series of data manipulations: filtering the products in stock, converting prices to a different currency, and calculating the average price of the remaining products. In the absence of the pipe operator, the code might resemble this:\n\n# Without the pipe operator\nin_stock_products &lt;- filter(products, stock_quantity &gt; 0)\nconverted_prices &lt;- mutate(in_stock_products, price_usd = price * exchange_rate)\naverage_price &lt;- mean(converted_prices$price_usd)\n\nIn this code, you must create intermediate variables (in_stock_products and converted_prices) to store the results at each step, which diminishes code readability.\nWith the Pipe Operator:\nNow, let’s rewrite the same task using the pipe operator:\n\naverage_price &lt;- products |&gt;\n  filter(stock_quantity &gt; 0) |&gt;\n  mutate(price_usd = price * exchange_rate) |&gt;\n  summarise(average_price = mean(price_usd))\n\nWith the pipe operator, the code unfolds as a coherent sequence, and you can execute operations on the data frame step by step, without the need for interim variables. This enhances code readability and facilitates comprehension. Each operation is distinct, and their order aligns with the logical flow of data manipulation.\nThe pipe operator also accommodates more intricate chains of operations, further enhancing code clarity. Here’s an extended example where we filter products, group them by category, calculate the average price for each category, and then sort the results:\n\nresult &lt;- products |&gt;\n  filter(stock_quantity &gt; 0) |&gt;\n  group_by(category) |&gt;\n  mutate(price_usd = price * exchange_rate) |&gt;\n  summarise(average_price = mean(price_usd)) |&gt;\n  arrange(desc(average_price))\n\nThe tidyverse represents a significant change in data analysis. Beyond simplifying data manipulation, it comprises a collection of packages designed to streamline data handling, analysis, and visualization. With tools like dplyr for efficient data manipulation and ggplot2 for effective data visualization, the tidyverse reshapes data analysis by providing a cohesive toolkit for modern data-driven tasks, benefiting data scientists and analysts."
  },
  {
    "objectID": "intro.html#navigating-the-tidyverse-in-r",
    "href": "intro.html#navigating-the-tidyverse-in-r",
    "title": "1  Introduction",
    "section": "1.3 Navigating the Tidyverse in R",
    "text": "1.3 Navigating the Tidyverse in R\nIn the following sections, we will dive into the practical application of R and the Tidyverse libraries. This guide aims to provide a hands-on demonstration of how to effectively use R and the Tidyverse for data manipulation and analysis.\nWe will explore a set of examples that illustrate the integration of Tidyverse libraries, such as dplyr for data manipulation and ggplot2 for data visualization, among others. These libraries have significantly improved the way data scientists and analysts work with data, streamlining the entire process and making it more accessible.\n\n1.3.1 Key Topics to Be Covered\n\nData Manipulation with dplyr: We will walk through the process of using dplyr functions like filter(), mutate(), select(), and more to efficiently filter, transform, and summarize data.\nTaming Data with tidyr: You will learn how to reshape and tidy your data with the tidyr package, making it easier to work with in downstream analyses.\nChaining Operations with the Pipe Operator (|&gt;): Building on the concept introduced earlier, we will explore how to use the pipe operator to create clear and efficient data manipulation workflows.\nGrouping and Aggregating Data: group_by() and summarize(): Discover how to group data by specific variables and then calculate summary statistics for those groups.\nData Visualization with ggplot2: We’ll demonstrate how to create stunning and informative data visualizations using the ggplot2 package, allowing you to convey your insights effectively.\n\nOur aim is to provide you with the foundational knowledge and practical skills required to begin your journey in R through the tidyverse libraries. Upon completing this material, you will emerge with a strong sense of confidence in your ability to proficiently conduct data analysis, visualization, and manipulation."
  },
  {
    "objectID": "start.html#installing-r-and-rstudio",
    "href": "start.html#installing-r-and-rstudio",
    "title": "2  Installation",
    "section": "2.1 Installing R and Rstudio",
    "text": "2.1 Installing R and Rstudio\nTo install R, go to the official R website: https://www.r-project.org/ and follow these steps based on your operating system:\n\n2.1.1 On Windows\n\nIn the left menu, select “CRAN.”\nChoose the “Download R for Windows” option.\nSelect the “base” option.\nOn the following page, choose the CRAN mirror closest to your location.\nDownload the latest version (e.g., “R-x.x.x for Windows”).\nDouble-click the downloaded file and follow the installation instructions.\n\n\n\n2.1.2 On Linux\n\nIn the left menu, select “CRAN.”\nChoose the “Download R for Linux” option.\nSelect the CRAN mirror closest to your location.\nChoose the link for your specific distribution.\nFollow the instructions provided on the page to install R.\n\n\n\n2.1.3 On macOS\n\nIn the left menu, select “CRAN.”\nChoose the “Download R for (Mac) OS X” option.\nSelect the CRAN mirror closest to your location.\nChoose the version you want (usually the latest version with a filename like “R-x.x.x.pkg”).\nDouble-click the downloaded file and follow the installation instructions."
  },
  {
    "objectID": "start.html#installing-rstudio",
    "href": "start.html#installing-rstudio",
    "title": "2  Installation",
    "section": "2.2 Installing Rstudio",
    "text": "2.2 Installing Rstudio\nTo install RStudio on Windows, follow these steps:\n\nVisit the RStudio downloads page by clicking on the link below:\nRStudio Downloads Page\nDownload the version that matches your operating system from the “All Installers” list.\nDouble-click the file you downloaded from the RStudio page and follow the installation instructions."
  },
  {
    "objectID": "start.html#integrated-development-environments-ides",
    "href": "start.html#integrated-development-environments-ides",
    "title": "2  Installation",
    "section": "2.3 Integrated Development Environments (IDEs)",
    "text": "2.3 Integrated Development Environments (IDEs)\n\n2.3.1 The Rstudio IDE\nIntegrated Development Environments (IDEs) play a crucial role in programming, providing an interactive and organized environment for developers. In the realm of the R programming language, one of the most popular IDEs is RStudio.\n\n\n\nA view of RStudio IDE\n\n\nRStudio is an open-source IDE specifically designed for R. It offers several key components:\n\nRStudio Interface:\n\nConsole: Execute R commands interactively.\nScript Editor: Write and edit R scripts with syntax highlighting and code suggestions.\nEnvironment and History: Monitor variables and functions, review command history.\nPlots and Visualizations: View interactive graphics generated from your code.\n\nProject Concept: RStudio encourages the use of projects to organize your data analysis or R development work. A project is an isolated workspace that contains all project-related files, scripts, data, and settings, enhancing organization and collaboration.\nR Scripts: R scripts are files containing R code for batch or interactive execution. Create and edit R scripts directly in RStudio, with integrated variable and object management.\nRData Files: RData files are native R data files used to save and load R objects (e.g., data frames, lists, variables) for reuse in R sessions.\n\nRStudio is a powerful and versatile IDE for R, catering to data scientists, analysts, and developers. Its user-friendly interface and integrated features enhance productivity and efficiency in data analysis and statistical programming.\n\n\n2.3.2 Cheat Sheets\nWhen it comes to learning more about RStudio and various R libraries, an invaluable resource at your disposal is the cheat sheets.\nIn RStudio, cheat sheets are available to provide concise summaries on how to utilize a range of packages, including insights into the functionality of RStudio itself. To access these cheat sheets, simply follow these steps:\n\nLaunch RStudio.\nNavigate to the “Help” menu located in the top menu bar of the window.\nWithin the “Help” menu, you’ll discover an option labeled “Cheat Sheets.” Click on this option.\nThis action will present you with a selection of available cheat sheets. Choose the one that is pertinent to the package or subject matter you wish to delve into.\nClick on the specific cheat sheet of your choice to open it. It will be displayed in a new browser tab or in a PDF viewer, depending on your RStudio’s configuration.\n\nThese cheat sheets contain succinct information and valuable insights on how to effectively utilize a variety of R features and specific packages. They serve as an excellent resource for swift reference and efficient learning.\n\n\n\nThe Rstudio cheat sheet"
  },
  {
    "objectID": "basics.html#syntax-object-types-and-structure",
    "href": "basics.html#syntax-object-types-and-structure",
    "title": "3  Basics",
    "section": "3.1 Syntax, object types and structure",
    "text": "3.1 Syntax, object types and structure\nIn R, you work with a variety of data types to represent and manipulate information. Understanding these data types is essential for effective data analysis. Let’s expand upon the data types in the context of the provided text.\n\n3.1.1 Character\nCharacter data types are used to represent text or strings. They are enclosed in single or double quotes and are ideal for working with labels, names, or textual data.\nExample:\n\n# Name of a dairy cow\ncow_name &lt;- \"Bessie\"\n\n\n\n3.1.2 Factor\nFactors are a unique data type in R, often used to represent categorical data. They have predefined levels, making them suitable for variables with distinct categories or levels.\nExample:\n\n# Cow breeds as a factor\ncow_breeds &lt;- factor(c(\"Holstein\", \"Jersey\", \"Guernsey\", \"Simmental\"))\n\n\n\n3.1.3 Double\nDouble data types represent numeric values, typically in decimal form. They are used for storing continuous, real-valued data, such as measurements and percentages.\nExample:\n\n# Milk production in gallons\nmilk_production_gallons &lt;- 15.5\n\n\n\n3.1.4 Integer\nInteger data types are used for whole numbers without decimal points. They are ideal for representing counts, quantities, or discrete values.\nExample:\n\n# Number of calves born\nnum_calves &lt;- 5L  # The 'L' indicates it's an integer\n\n\n\n3.1.5 Logical\nLogical data types, often referred to as booleans, represent binary values: TRUE or FALSE. They are essential for making logical comparisons and decisions in your code.\nExample:\n\n# Is the cow healthy?\nis_healthy &lt;- TRUE\n\n\n\n3.1.6 Date\nDate data types are used to work with dates and times. They allow you to represent specific points in time, including date and time together, in a structured manner.\nExample:\n\n# Date of last milk collection\nlast_milk_collection &lt;- as.Date(\"2023-10-25\")\n\n\n\n3.1.7 Lists\nLists are a versatile data type in R, capable of storing various objects of different types. They can contain scalars, vectors, data frames, and more.\nExample:\n\n# Information about a dairy farm as a list\nfarm_info &lt;- list(farm_name = \"Green Meadows\", location = \"Wisconsin\", cows = c(550, 600, 520, 580, 630), is_organic = FALSE)\n\nVarious types of data can be organized using a diverse range of data structures, as previously mentioned scalars, vectors, matrices, and data frames.\n\n\n3.1.8 Scalars\nScalars are single values in R. They can be integers, decimals, or characters. You might use scalars to represent individual data points.\nExample:\n\n# Number of dairy cows on a farm\nnum_cows &lt;- 100\n\n\n\n3.1.9 Vectors\nVectors are one-dimensional arrays that can store multiple values of the same data type. They are commonly used in R to work with collections of data. For example, you might use vectors to store information about individual cow weights.\nExample:\n\n# Weight of dairy cows in kilograms\ncow_weights &lt;- c(550, 600, 520, 580, 630)\n\n\n\n3.1.10 Matrices\nMatrices are two-dimensional arrays that can store data of the same data type. You might use matrices to represent data tables, like the weights of multiple cows over time.\nExample:\n\n# Create a matrix with cow weights for two weeks\ncow_weight_matrix &lt;- matrix(c(550, 600, 520, 580, 630, 560, 610, 530, 590, 640), nrow = 5, byrow = TRUE)\ncolnames(cow_weight_matrix) &lt;- c(\"Week1\", \"Week2\")\nrownames(cow_weight_matrix) &lt;- c(\"Cow1\", \"Cow2\", \"Cow3\", \"Cow4\", \"Cow5\")\n\n\n\n3.1.11 Data Frames\nData frames are a common data structure in R, designed for tabular data. They can store different types of data (e.g., scalars, vectors) in columns. You might use data frames to organize data like cow ID, age, weight, and milk production.\nExample:\n\n# Create a data frame with information about dairy cows\ndairy_cows &lt;- data.frame(\n  ID = c(1, 2, 3, 4, 5),\n  Name = c(\"Bessie\", \"MooMoo\", \"Daisy\", \"Buttercup\", \"Elsie\"),\n  Age = c(5, 4, 6, 3, 7),\n  Weight_kg = cow_weights,\n  Milk_Production_liters = c(20, 18, 22, 19, 21)\n)"
  },
  {
    "objectID": "basics.html#pre-compiled-functions",
    "href": "basics.html#pre-compiled-functions",
    "title": "3  Basics",
    "section": "3.2 Pre-compiled Functions",
    "text": "3.2 Pre-compiled Functions\nR provides pre-compiled functions and data structures that optimize the efficiency of working with these objects. Some of these functions have been demonstrated in the earlier examples, including:\n\nCombining elements: The c() function is fundamental in R for creating vectors by combining individual elements.\nMatrices: You can create matrices using the matrix() function to organize structured data.\nData Frames: The data.frame() function is employed to establish data frames for tabular data.\n\nHowever, there are numerous others, including:\n\nSummary Statistics: R offers pre-compiled functions like mean(), median(), and summary() for in-depth data analysis.\nPlotting: R provides functions such as plot() and hist() for crafting data visualizations.\n\nThese pre-compiled functions and data structures simplify the process of working with data, enabling efficient data manipulation and analysis.\nCertainly, here’s the revised version, including information about what “val” represents:"
  },
  {
    "objectID": "basics.html#understanding-the-generic-structure-of-an-r-function",
    "href": "basics.html#understanding-the-generic-structure-of-an-r-function",
    "title": "3  Basics",
    "section": "3.3 Understanding the Generic Structure of an R Function",
    "text": "3.3 Understanding the Generic Structure of an R Function\nIn R, every function adheres to a consistent and generic structure, typically defined as:\n\nfunction_name(arg1 = val, arg2 = val, arg3 = val, ..., argN = val)\n\n\nfunction_name: This is the name of the R function, and it signifies the specific operation that the function performs.\narg1, arg2, arg3, …, argN: These represent the function’s arguments, encapsulated within parentheses. Arguments are placeholders for the values or parameters that you provide to the function. The number and type of arguments may vary depending on the specific function.\n\nIn this context, “val” is a placeholder for the actual values or parameters you would provide when calling the function. The “val” should be replaced with specific values relevant to the function’s operation.\nExample:\n\n# Generic structure of a function\nresult &lt;- mean(x = c(1, 2, 3, NA), na.rm = T)"
  },
  {
    "objectID": "basics.html#dealing-with-na-values-in-r",
    "href": "basics.html#dealing-with-na-values-in-r",
    "title": "3  Basics",
    "section": "3.4 Dealing with “NA” Values in R",
    "text": "3.4 Dealing with “NA” Values in R\nIn R, “NA” represents missing or undefined data. It stands for “Not Available” and is used to indicate missing values. You may encounter different types of “NA” values, each tailored to specific data types. To handle missing data:\n\nDetect NAs with is.na() or complete.cases().\nRemove NAs using functions like na.omit().\nReplace NAs with specific values when needed.\nIgnore NAs in calculations using the na.rm parameter.\n\nExample:\n\n# Create a vector with missing data (NAs)\ndata_vector &lt;- c(12, NA, 25, 18, NA, 30)\n\n# Detect NAs in the vector\nna_indices &lt;- which(is.na(data_vector))\n\n# Remove NAs and create a new vector\nclean_vector &lt;- na.omit(data_vector)\n\n# Replace NAs with a specific value (e.g., 0)\ndata_vector[is.na(data_vector)] &lt;- 0\n\n# Calculate the mean of the cleaned vector, ignoring NAs\nmean_value &lt;- mean(clean_vector, na.rm = TRUE)\n\n# Print the results\ncat(\"Original Data Vector: \", data_vector, \"\\n\")\n\nOriginal Data Vector:  12 0 25 18 0 30 \n\ncat(\"Indices of NAs: \", na_indices, \"\\n\")\n\nIndices of NAs:  2 5 \n\ncat(\"Cleaned Data Vector: \", clean_vector, \"\\n\")\n\nCleaned Data Vector:  12 25 18 30 \n\ncat(\"Mean Value (Ignoring NAs): \", mean_value, \"\\n\")\n\nMean Value (Ignoring NAs):  21.25"
  },
  {
    "objectID": "basics.html#libraries",
    "href": "basics.html#libraries",
    "title": "3  Basics",
    "section": "3.5 Libraries",
    "text": "3.5 Libraries\nIn R, libraries are collections of functions and datasets that extend the capabilities of the base R system. They provide additional tools and functions for various tasks, such as data manipulation, visualization, and statistical analysis. Libraries are crucial for enhancing your data analysis and programming capabilities in R.\n\n3.5.1 Installing and Loading Libraries in R\nTo use a library in R, you first need to install it (usually only once) and then load it (each time you start a new R session) using the library() function. You can install and load libraries using RStudio or directly in R.\nExample: Installing and Loading the “tidyverse” Library in RStudio\n\nOpen RStudio.\nIn the RStudio console, you can install the “tidyverse” library using the install.packages() function:\n\n\ninstall.packages(\"tidyverse\")\n\nThis command will download and install the “tidyverse” package from the Comprehensive R Archive Network (CRAN).\n\nOnce the installation is complete, load the “tidyverse” library using the library() function:\n\n\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.2     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.3     ✔ tibble    3.2.1\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nLoading the “tidyverse” library makes its functions and data manipulation tools available for your R session.\nNow you can take advantage of the powerful data analysis and visualization tools provided by the “tidyverse” package in your RStudio environment.\nLibraries like “tidyverse” are essential for extending R’s functionality and making it a powerful platform for data analysis and statistical computing."
  },
  {
    "objectID": "basics.html#data-import-in-r",
    "href": "basics.html#data-import-in-r",
    "title": "3  Basics",
    "section": "3.6 Data Import in R",
    "text": "3.6 Data Import in R\nData import is a crucial step in data analysis using R. R provides various functions and packages to import and manipulate data from different sources. Here, we’ll cover how to import pre-available data and work with commonly used file formats like CSV, TXT, and Excel.\n\n3.6.1 Importing Pre-Available Data\nIn R, there are built-in datasets that you can use for practice and analysis. One such dataset is the “mtcars” dataset.\n\n# Load the built-in \"mtcars\" dataset\ndata(mtcars)\n\n# View the first few rows of the dataset\nhead(mtcars)\n\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\n\nThe “mtcars” dataset is now available for analysis.\n\n\n3.6.2 Importing Data from CSV\nSuppose you have data in a CSV (Comma-Separated Values) file. You can use the read_csv() function from the Tidyverse to import it. Here’s an example:\n\n# Import data from a CSV file\nmy_data &lt;- read_csv(\"my_data.csv\")\n\n# Display the first few rows of the imported data\nhead(my_data)\n\nReplace \"my_data.csv\" with the actual path to your CSV file.\n\n\n3.6.3 Importing Data from Text (TXT) Files\nTo import data from a plain text file, you can use the read_delim() function from Tidyverse. This function is versatile and can handle various delimiters, making it suitable for tab-delimited or space-delimited files. Here’s an example:\n\n# Import data from a text file\nmy_data &lt;- read_delim(\"my_data.txt\", delim = \"\\t\")\n\n# Display the first few rows of the imported data\nhead(my_data)\n\nReplace \"my_data.txt\" with the actual path to your text file and adjust the delim parameter as needed to match your file’s delimiter.\n\n\n3.6.4 Importing Data from Excel\nTo import data from Excel files, you can use the readxl package. First, install the package and then use the read_excel() function to import data from an Excel file.\nAssuming you have an Excel file named \"dairy_data.xlsx\" with a sheet named \"Cattle_Info\", you can import it as follows:\n\n# Install and load the \"readxl\" package (install only once)\n# install.packages(\"readxl\")\nlibrary(readxl)\n\n# Import data from an Excel file\ncattle_data_excel &lt;- read_excel(\"dairy_data.xlsx\", sheet = \"Cattle_Info\")\n\n# View the first few rows of the imported data\nhead(cattle_data_excel)\n\n\n\n3.6.5 Beyond Local Files\nBeyond local data storage, R enables you to seamlessly import datasets from the internet. This functionality provides access to a wide range of online data sources.\nTo import a dataset from the internet into R, you can employ the functions previously discussed, depending on the file format accessible via a URL. Let’s illustrate this with a practical example involving a .csv file related to milk production for dairy cows, hosted on GitHub. Here’s how to import this data into R:\n\n# Define the URL of the dataset\ndata_url &lt;- \"https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2019/2019-01-29/state_milk_production.csv\"\n\n\n# Import data from the internet\nstate_milk_production &lt;- read_csv(data_url, show_col_types = FALSE)\n\n# View the first few rows of the imported data\nhead(state_milk_production)\n\n# A tibble: 6 × 4\n  region    state          year milk_produced\n  &lt;chr&gt;     &lt;chr&gt;         &lt;dbl&gt;         &lt;dbl&gt;\n1 Northeast Maine          1970     619000000\n2 Northeast New Hampshire  1970     356000000\n3 Northeast Vermont        1970    1970000000\n4 Northeast Massachusetts  1970     658000000\n5 Northeast Rhode Island   1970      75000000\n6 Northeast Connecticut    1970     661000000"
  },
  {
    "objectID": "manip.html#basic-data-manipulation-with-dplyr",
    "href": "manip.html#basic-data-manipulation-with-dplyr",
    "title": "4  Data manipulation",
    "section": "4.1 Basic Data Manipulation with dplyr",
    "text": "4.1 Basic Data Manipulation with dplyr\nWe’ll cover the fundamental data manipulation functions provided by the dplyr package in R such as: mutate() for adding or modifying variables, summarize() for calculating summary statistics ,group_by() and ungroup() for grouping and ungrouping data,filter() fro filtering rows, select() for selecting columns and arrange() for sorting data.\n\n\nmutate() - Adding or Modifying Variables\nThe mutate() function is used to create new variables or modify existing ones.\n\n# Adding a new variable: milk_per_cow_kg\nmutated_data &lt;- state_milk_production |&gt;\n  mutate(milk_produced_kg = milk_produced * 0.453592)  # Convert pounds to kilograms\n\nprint(mutated_data)\n\n# A tibble: 2,400 × 5\n   region    state          year milk_produced milk_produced_kg\n   &lt;chr&gt;     &lt;chr&gt;         &lt;dbl&gt;         &lt;dbl&gt;            &lt;dbl&gt;\n 1 Northeast Maine          1970     619000000        280773448\n 2 Northeast New Hampshire  1970     356000000        161478752\n 3 Northeast Vermont        1970    1970000000        893576240\n 4 Northeast Massachusetts  1970     658000000        298463536\n 5 Northeast Rhode Island   1970      75000000         34019400\n 6 Northeast Connecticut    1970     661000000        299824312\n 7 Northeast New York       1970   10341000000       4690594872\n 8 Northeast New Jersey     1970     730000000        331122160\n 9 Northeast Pennsylvania   1970    7124000000       3231389408\n10 Northeast Delaware       1970     130000000         58966960\n# ℹ 2,390 more rows\n\n\n\n\n\nsummarize() - Calculating Summary Statistics\nThe summarize() function calculates summary statistics for a specific group.\n\n# Calculate the total milk produced for each state\nsummary_data &lt;- state_milk_production |&gt;\n  group_by(state) |&gt;\n  summarize(total_milk_produced = sum(milk_produced))\nprint(summary_data)\n\n# A tibble: 50 × 2\n   state       total_milk_produced\n   &lt;chr&gt;                     &lt;dbl&gt;\n 1 Alabama             20764000000\n 2 Alaska                675000000\n 3 Arizona            116937000000\n 4 Arkansas            26070000000\n 5 California        1219691000000\n 6 Colorado            86232000000\n 7 Connecticut         24574000000\n 8 Delaware             6094000000\n 9 Florida            106660000000\n10 Georgia             67745000000\n# ℹ 40 more rows\n\n\n\n\n\ngroup_by() - Grouping Data\nThe group_by() function is used to group data by a specific variable.\n\n# Group data by year and calculate the average milk produced\ngrouped_data &lt;- state_milk_production |&gt;\n  group_by(year) |&gt;\n  summarize(avg_milk_produced = mean(milk_produced))\n\nprint(grouped_data)\n\n# A tibble: 48 × 2\n    year avg_milk_produced\n   &lt;dbl&gt;             &lt;dbl&gt;\n 1  1970        2340140000\n 2  1971        2371320000\n 3  1972        2400500000\n 4  1973        2309820000\n 5  1974        2311720000\n 6  1975        2307960000\n 7  1976        2403600000\n 8  1977        2453080000\n 9  1978        2429220000\n10  1979        2467020000\n# ℹ 38 more rows\n\n\n\n\n\nfilter() - Filtering Rows\nThe filter() function is used to filter rows based on a condition.\n\n# Filter data for the year 2022\nfiltered_data &lt;- state_milk_production %&gt;%\n  filter(year == 2022)\n\nprint(filtered_data)\n\n# A tibble: 0 × 4\n# ℹ 4 variables: region &lt;chr&gt;, state &lt;chr&gt;, year &lt;dbl&gt;, milk_produced &lt;dbl&gt;\n\n\n\n\n\nselect() - Selecting Columns\nThe select() function is used to select specific columns.\n\n# Select only the \"state\" and \"milk_produced\" columns\nselected_data &lt;- state_milk_production %&gt;%\n  select(state, milk_produced)\n\nprint(selected_data)\n\n# A tibble: 2,400 × 2\n   state         milk_produced\n   &lt;chr&gt;                 &lt;dbl&gt;\n 1 Maine             619000000\n 2 New Hampshire     356000000\n 3 Vermont          1970000000\n 4 Massachusetts     658000000\n 5 Rhode Island       75000000\n 6 Connecticut       661000000\n 7 New York        10341000000\n 8 New Jersey        730000000\n 9 Pennsylvania     7124000000\n10 Delaware          130000000\n# ℹ 2,390 more rows\n\n\n\n\n\n4.1.1 arrange() - Sorting Data\nThe arrange() function is used to sort data by one or more variables.\n\n# Arrange data by year in descending order\nsorted_data &lt;- state_milk_production %&gt;%\n  arrange(desc(year))\n\nprint(sorted_data)\n\n# A tibble: 2,400 × 4\n   region    state          year milk_produced\n   &lt;chr&gt;     &lt;chr&gt;         &lt;dbl&gt;         &lt;dbl&gt;\n 1 Northeast Maine          2017     630000000\n 2 Northeast New Hampshire  2017     273000000\n 3 Northeast Vermont        2017    2728000000\n 4 Northeast Massachusetts  2017     211000000\n 5 Northeast Rhode Island   2017      13000000\n 6 Northeast Connecticut    2017     420000000\n 7 Northeast New York       2017   14912000000\n 8 Northeast New Jersey     2017     119000000\n 9 Northeast Pennsylvania   2017   10938000000\n10 Northeast Delaware       2017      93000000\n# ℹ 2,390 more rows"
  },
  {
    "objectID": "manip.html#extended-data-manipulation-with-dplyr",
    "href": "manip.html#extended-data-manipulation-with-dplyr",
    "title": "4  Data manipulation",
    "section": "4.2 Extended Data Manipulation with dplyr",
    "text": "4.2 Extended Data Manipulation with dplyr\nIn order to demonstrate advanced data manipulation with the dplyr package, we’ll begin by importing another dataset from the United States Department of Agriculture (USDA), known as the ‘milkcow_facts.csv’ dataset.\nYou can access the original data here. The dataset contains the following variables:\n\n\n\n\n\n\n\n\nVariable\nClass\nDescription\n\n\n\n\nyear\ndate\nYear\n\n\navg_milk_cow_number\ndouble\nAverage number of milk cows\n\n\nmilk_per_cow\ndouble\nAverage milk production per cow in pounds\n\n\nmilk_production_lbs\ndouble\nTotal milk production in pounds\n\n\navg_price_milk\ndouble\nAverage price paid for milk (dollars per pound)\n\n\ndairy_ration\ndouble\nAverage price paid for dairy cow rations (dollars per pound)\n\n\nmilk_feed_price_ratio\ndouble\nRatio of average price of milk per dairy cow ration\n\n\nmilk_cow_cost_per_animal\ndouble\nAverage cost of a milk cow per animal (dollars)\n\n\nmilk_volume_to_buy_cow_in_lbs\ndouble\nMilk volume required to purchase a cow (pounds)\n\n\nalfalfa_hay_price\ndouble\nAlfalfa hay price received by farmers (tons)\n\n\nslaughter_cow_price\ndouble\nSlaughter cow price (value of meat in dollars per pound)\n\n\n\nThe subsequent code imports data using the method previously introduced in the preceding chapter:\n\n# Define the URL of the dataset\ndata_url &lt;- \"https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2019/2019-01-29/milkcow_facts.csv\"\n\n# Import data from the internet\nmilk_cow_facts &lt;- read_csv(data_url, show_col_types = FALSE)\n\n\njoin() - Combining datasets\nThe join() function is used to combine multiple datasets based on common keys, allowing you to create more complex datasets.\n\n# Joining two datasets based on a common variable (e.g., year)\ncombined_data &lt;- milk_cow_facts |&gt;\n  left_join(grouped_data, by = \"year\")\n\nprint(combined_data)\n\n# A tibble: 35 × 12\n    year avg_milk_cow_number milk_per_cow milk_production_lbs avg_price_milk\n   &lt;dbl&gt;               &lt;dbl&gt;        &lt;dbl&gt;               &lt;dbl&gt;          &lt;dbl&gt;\n 1  1980            10799000        11891        128406000000          0.13 \n 2  1981            10898000        12183        132770000000          0.138\n 3  1982            11011000        12306        135505000000          0.136\n 4  1983            11059000        12622        139588000000          0.136\n 5  1984            10793000        12541        135351000000          0.135\n 6  1985            10981000        13024        143012000000          0.127\n 7  1986            10773000        13285        143124000000          0.125\n 8  1987            10327000        13819        142709000000          0.125\n 9  1988            10224000        14185        145034000000          0.122\n10  1989            10046000        14323        143893000000          0.136\n# ℹ 25 more rows\n# ℹ 7 more variables: dairy_ration &lt;dbl&gt;, milk_feed_price_ratio &lt;dbl&gt;,\n#   milk_cow_cost_per_animal &lt;dbl&gt;, milk_volume_to_buy_cow_in_lbs &lt;dbl&gt;,\n#   alfalfa_hay_price &lt;dbl&gt;, slaughter_cow_price &lt;dbl&gt;, avg_milk_produced &lt;dbl&gt;\n\n\n\n\n\nAdvanced Filtering with between()\nIn data analysis, advanced filtering often requires the ability to select rows based on specific numeric ranges. The between() function in R is a powerful tool that enables advanced filtering by allowing you to extract rows where a variable falls within a defined range. Let’s explore how to use this function for more complex filtering tasks. For instance, suppose you want to perform advanced filtering to select rows with years falling within the range of 2015 to 2020:\n\n# Advanced filtering: Select data for a specific range of years\nfiltered_data &lt;- state_milk_production |&gt;\n  filter(between(year, 2015, 2020))\n\nprint(filtered_data)\n\n# A tibble: 150 × 4\n   region    state          year milk_produced\n   &lt;chr&gt;     &lt;chr&gt;         &lt;dbl&gt;         &lt;dbl&gt;\n 1 Northeast Maine          2015     594000000\n 2 Northeast New Hampshire  2015     282000000\n 3 Northeast Vermont        2015    2666000000\n 4 Northeast Massachusetts  2015     217000000\n 5 Northeast Rhode Island   2015      16000000\n 6 Northeast Connecticut    2015     396000000\n 7 Northeast New York       2015   14094000000\n 8 Northeast New Jersey     2015     127000000\n 9 Northeast Pennsylvania   2015   10800000000\n10 Northeast Delaware       2015      99000000\n# ℹ 140 more rows\n\n\n\n\n\ncase_when() - Conditional transformations filtered_data\nThe case_when() function is used to perform conditional transformations, allowing you to create new variables based on multiple conditions.\n\n# Create a new variable \"milk_prod\" based on conditions\ntransformed_data &lt;- milk_cow_facts |&gt;\n  mutate(milk_prod = case_when(\n    milk_per_cow &gt; 19000 ~ \"High\",\n    milk_per_cow &gt; 14000 ~ \"Medium\",\n    TRUE ~ \"Low\"\n  ))\n\nprint(transformed_data)\n\n# A tibble: 35 × 12\n    year avg_milk_cow_number milk_per_cow milk_production_lbs avg_price_milk\n   &lt;dbl&gt;               &lt;dbl&gt;        &lt;dbl&gt;               &lt;dbl&gt;          &lt;dbl&gt;\n 1  1980            10799000        11891        128406000000          0.13 \n 2  1981            10898000        12183        132770000000          0.138\n 3  1982            11011000        12306        135505000000          0.136\n 4  1983            11059000        12622        139588000000          0.136\n 5  1984            10793000        12541        135351000000          0.135\n 6  1985            10981000        13024        143012000000          0.127\n 7  1986            10773000        13285        143124000000          0.125\n 8  1987            10327000        13819        142709000000          0.125\n 9  1988            10224000        14185        145034000000          0.122\n10  1989            10046000        14323        143893000000          0.136\n# ℹ 25 more rows\n# ℹ 7 more variables: dairy_ration &lt;dbl&gt;, milk_feed_price_ratio &lt;dbl&gt;,\n#   milk_cow_cost_per_animal &lt;dbl&gt;, milk_volume_to_buy_cow_in_lbs &lt;dbl&gt;,\n#   alfalfa_hay_price &lt;dbl&gt;, slaughter_cow_price &lt;dbl&gt;, milk_prod &lt;chr&gt;\n\n\n\n\n\nmutate_at() - Applying functions to multiple columns.\nThe mutate_at() function allows you to apply a function to multiple columns simultaneously.\n\n# Apply the transformation to selected columns\ntransformed_data &lt;- milk_cow_facts |&gt;\n  mutate_at(vars(milk_production_lbs, milk_per_cow), function(x) x * 0.453592)\n\nprint(transformed_data)\n\n# A tibble: 35 × 11\n    year avg_milk_cow_number milk_per_cow milk_production_lbs avg_price_milk\n   &lt;dbl&gt;               &lt;dbl&gt;        &lt;dbl&gt;               &lt;dbl&gt;          &lt;dbl&gt;\n 1  1980            10799000        5394.         58243934352          0.13 \n 2  1981            10898000        5526.         60223409840          0.138\n 3  1982            11011000        5582.         61463983960          0.136\n 4  1983            11059000        5725.         63316000096          0.136\n 5  1984            10793000        5688.         61394130792          0.135\n 6  1985            10981000        5908.         64869099104          0.127\n 7  1986            10773000        6026.         64919901408          0.125\n 8  1987            10327000        6268.         64731660728          0.125\n 9  1988            10224000        6434.         65786262128          0.122\n10  1989            10046000        6497.         65268713656          0.136\n# ℹ 25 more rows\n# ℹ 6 more variables: dairy_ration &lt;dbl&gt;, milk_feed_price_ratio &lt;dbl&gt;,\n#   milk_cow_cost_per_animal &lt;dbl&gt;, milk_volume_to_buy_cow_in_lbs &lt;dbl&gt;,\n#   alfalfa_hay_price &lt;dbl&gt;, slaughter_cow_price &lt;dbl&gt;\n\n\n\n\n\ngroup_by() with multiple variables - Multi-level grouping\nYou can use group_by() with multiple variables to create multi-level grouping for more complex summaries.\n\n# Group data by region and year and calculate summary statistics\nmulti_level_grouped_data &lt;- state_milk_production |&gt;\n  group_by(region, year) |&gt;\n  summarize(total_milk_produced = sum(milk_produced))\n\nprint(multi_level_grouped_data)\n\n# A tibble: 480 × 3\n# Groups:   region [10]\n   region       year total_milk_produced\n   &lt;chr&gt;       &lt;dbl&gt;               &lt;dbl&gt;\n 1 Appalachian  1970          8202000000\n 2 Appalachian  1971          8216000000\n 3 Appalachian  1972          8389000000\n 4 Appalachian  1973          7900000000\n 5 Appalachian  1974          7858000000\n 6 Appalachian  1975          7953000000\n 7 Appalachian  1976          8292000000\n 8 Appalachian  1977          8434000000\n 9 Appalachian  1978          8109000000\n10 Appalachian  1979          8163000000\n# ℹ 470 more rows"
  },
  {
    "objectID": "manip.html#exercises",
    "href": "manip.html#exercises",
    "title": "4  Data manipulation",
    "section": "4.3 Exercises",
    "text": "4.3 Exercises\n\nExercise 1: Filtering and Selecting\nFilter the milk_cow_facts dataset to retain only rows for the year 2015. Then, select and display the total milk production in pounds (milk_produced).\n\n# Exercise 1: Filtering and Selecting\nfiltered_data &lt;- state_milk_production |&gt;\n  filter(year == 2015) |&gt;\n  select(state, milk_produced)\n\nfiltered_data\n\n# A tibble: 50 × 2\n   state         milk_produced\n   &lt;chr&gt;                 &lt;dbl&gt;\n 1 Maine             594000000\n 2 New Hampshire     282000000\n 3 Vermont          2666000000\n 4 Massachusetts     217000000\n 5 Rhode Island       16000000\n 6 Connecticut       396000000\n 7 New York        14094000000\n 8 New Jersey        127000000\n 9 Pennsylvania    10800000000\n10 Delaware           99000000\n# ℹ 40 more rows\n\n\n\n\n\nExercise 2: Grouping and Summarizing\nGroup the milkcow_facts dataset by the year variable. Calculate the average milk production per cow (milk_per_cow) for each year.\n\n# Exercise 2: Grouping and Summarizing\nsummary_data &lt;- milk_cow_facts |&gt;\n  group_by(year) |&gt;\n  summarize(avg_milk_per_cow = mean(milk_per_cow, na.rm = TRUE))\n\nsummary_data\n\n# A tibble: 35 × 2\n    year avg_milk_per_cow\n   &lt;dbl&gt;            &lt;dbl&gt;\n 1  1980            11891\n 2  1981            12183\n 3  1982            12306\n 4  1983            12622\n 5  1984            12541\n 6  1985            13024\n 7  1986            13285\n 8  1987            13819\n 9  1988            14185\n10  1989            14323\n# ℹ 25 more rows\n\n\n\n\n\nExercise 3: Calculating New Variables\nIn the milk_cow_facts dataset, calculate the ratio of the average price of milk per dairy cow ration (milk_feed_price_ratio) by dividing the average price paid for milk (avg_price_milk) by the average price paid for dairy cow rations (dairy_ration) in 2013.\n\n# Exercise 3: Calculating New Variables and filtering\nmilkcow_facts_2013 &lt;- milk_cow_facts |&gt;\n  filter(year == 2013) |&gt;\n  mutate(milk_feed_price_ratio = avg_price_milk / dairy_ration)\n\nmilkcow_facts_2013\n\n# A tibble: 1 × 11\n   year avg_milk_cow_number milk_per_cow milk_production_lbs avg_price_milk\n  &lt;dbl&gt;               &lt;dbl&gt;        &lt;dbl&gt;               &lt;dbl&gt;          &lt;dbl&gt;\n1  2013             9224000        21816        201231000000          0.201\n# ℹ 6 more variables: dairy_ration &lt;dbl&gt;, milk_feed_price_ratio &lt;dbl&gt;,\n#   milk_cow_cost_per_animal &lt;dbl&gt;, milk_volume_to_buy_cow_in_lbs &lt;dbl&gt;,\n#   alfalfa_hay_price &lt;dbl&gt;, slaughter_cow_price &lt;dbl&gt;\n\n\n\n\n\nExercise 4: Filter and sorting Data\nSort the state_milk_production dataset in descending order based on the milk_produced variable in 2014. Display the top 10 states with the highest production of milk in this year.\n\n# Exercise 4: Sorting Data\nsorted_data &lt;- state_milk_production %&gt;%\n  filter(year == 2014) %&gt;%\n  arrange(desc(milk_produced)) %&gt;%\n  head(10)\n\nsorted_data\n\n# A tibble: 10 × 4\n   region          state         year milk_produced\n   &lt;chr&gt;           &lt;chr&gt;        &lt;dbl&gt;         &lt;dbl&gt;\n 1 Pacific         California    2014   42339000000\n 2 Lake States     Wisconsin     2014   27795000000\n 3 Mountain        Idaho         2014   13873000000\n 4 Northeast       New York      2014   13730000000\n 5 Northeast       Pennsylvania  2014   10664000000\n 6 Southern Plains Texas         2014   10310000000\n 7 Lake States     Michigan      2014    9609000000\n 8 Lake States     Minnesota     2014    9127000000\n 9 Mountain        New Mexico    2014    8105000000\n10 Pacific         Washington    2014    6576000000\n\n\n\n\n\nExercise 5: Preparing Data for ggplot2 Visualization\nFor our upcoming exercise, we will be working with another two datasets: milk_products_facts and clean_cheese. These datasets offer valuable insights into consumption patterns of various dairy and cheese products in the United States over the years.\nTo import the milk_products_facts dataset, use the following code:\n\n# Define the URL of the dataset for milk products\nmilk_products_url &lt;- \"https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2019/2019-01-29/milk_products_facts.csv\"\n\n# Import data from the internet\nmilk_products_facts &lt;- read.csv(milk_products_url)\n\nTo import the clean_cheese dataset, use the following code:\n\n# Define the URL of the dataset for clean cheese products\nclean_cheese_url &lt;- \"https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2019/2019-01-29/clean_cheese.csv\"\n\n# Import data from the internet\nclean_cheese &lt;- read.csv(clean_cheese_url)\n\nHere’s a complete overview of the variables within each dataset:\nmilk_products_facts:\n\n\n\n\n\n\n\n\nVariable\nClass\nDescription\n\n\n\n\nyear\ndate\nYear\n\n\nfluid_milk\ndouble\nAverage milk consumption in pounds per person\n\n\nfluid_yogurt\ndouble\nAverage yogurt consumption in pounds per person\n\n\nbutter\ndouble\nAverage butter consumption in pounds per person\n\n\ncheese_american\ndouble\nAverage American cheese consumption in pounds per person\n\n\ncheese_other\ndouble\nAverage other cheese consumption in pounds per person\n\n\ncheese_cottage\ndouble\nAverage cottage cheese consumption in pounds per person\n\n\nevap_cnd_canned_whole_milk\ndouble\nAverage evaporated and canned whole milk consumption in pounds per person\n\n\nevap_cnd_bulk_whole_milk\ndouble\nAverage evaporated and canned bulk whole milk consumption in pounds per person\n\n\nevap_cnd_bulk_and_can_skim_milk\ndouble\nAverage evaporated and canned bulk and canned skim milk consumption in pounds per person\n\n\nfrozen_ice_cream_regular\ndouble\nAverage regular frozen ice cream consumption in pounds per person\n\n\nfrozen_ice_cream_reduced_fat\ndouble\nAverage reduced-fat frozen ice cream consumption in pounds per person\n\n\nfrozen_sherbet\ndouble\nAverage frozen sherbet consumption in pounds per person\n\n\nfrozen_other\ndouble\nAverage consumption of other frozen milk products in pounds per person\n\n\ndry_whole_milk\ndouble\nAverage consumption of dry whole milk in pounds per person\n\n\ndry_nonfat_milk\ndouble\nAverage consumption of dry nonfat milk in pounds per person\n\n\ndry_buttermilk\ndouble\nAverage consumption of dry buttermilk in pounds per person\n\n\ndry_whey\ndouble\nAverage consumption of dry whey (milk protein) in pounds per person\n\n\n\nclean_cheese:\n\n\n\n\n\n\n\n\nVariable\nClass\nDescription\n\n\n\n\nYear\ndate\nYear\n\n\nCheddar\ndouble\nCheddar consumption in pounds per person\n\n\nAmerican Other\ndouble\nAmerican Other consumption in pounds per person\n\n\nMozzarella\ndouble\nMozzarella consumption in pounds per person\n\n\nItalian Other\ndouble\nItalian Other consumption in pounds per person\n\n\nSwiss\ndouble\nSwiss consumption in pounds per person\n\n\nBrick\ndouble\nBrick consumption in pounds per person\n\n\nMuenster\ndouble\nMuenster consumption in pounds per person\n\n\nCream and Neufchatel\ndouble\nCream and Neufchatel consumption in pounds per person\n\n\nBlue\ndouble\nBlue consumption in pounds per person\n\n\nOther Dairy Cheese\ndouble\nOther Dairy Cheese consumption in pounds per person\n\n\nProcessed Cheese\ndouble\nProcessed Cheese consumption in pounds per person\n\n\nFoods and spreads\ndouble\nFoods and spreads consumption in pounds per person\n\n\nTotal American Cheese\ndouble\nTotal American Cheese consumption in pounds per person\n\n\nTotal Italian Cheese\ndouble\nTotal Italian Cheese consumption in pounds per person\n\n\nTotal Natural Cheese\ndouble\nTotal Natural Cheese consumption in pounds per person\n\n\nTotal Processed Cheese Products\ndouble\nTotal Processed Cheese Products consumption in pounds per person\n\n\n\nThese two datasets, like the previous ones, are also sourced from the same GitHub repository metioned before.\nQuestion\nIn this exercise, we will analyze and visualize the trends in cheese consumption in the United States. Specifically, we aim to understand the relationship between the consumption of American cheese and mozzarella cheese over the years.\nInstructions:\n\nSelect relevant variables from each dataset. From “milk_products_facts,” select “year” and “cheese_american.” From “clean_cheese,” select “Year” and “Mozzarella.”\nMerge the datasets using a common variable, which is “year.”\nCalculate the ratio of American cheese consumption to mozzarella consumption for each year.\nCreate a line plot using the ggplot2 package to visualize how the ratio of American cheese consumption to mozzarella consumption has changed over the years.\n\nAnswer:\n\n# Perform data manipulation\nmilk_products_facts &lt;- milk_products_facts %&gt;%\n  select(year, cheese_american) \n\nclean_cheese &lt;- clean_cheese %&gt;%\n  select(Year, Mozzarella) \n\n# Merge the datasets on the \"year\" variable\nmerged_data &lt;- left_join(milk_products_facts, clean_cheese, by = c(\"year\" = \"Year\"))\n\n# Calculate the ratio of American cheese consumption to mozzarella consumption\nmerged_data &lt;- merged_data %&gt;%\n  mutate(ratio = cheese_american / Mozzarella)\n\n# Create a line plot\nggplot(merged_data, aes(x = year, y = ratio)) +\n  geom_point() +\n  geom_line(color = \"blue\") +\n  labs(\n    x = \"Year\",\n    y = \"Ratio (American Cheese / Mozzarella)\",\n    title = \"Ratio of American Cheese to Mozzarella Consumption Over the Years\"\n  )"
  },
  {
    "objectID": "visual.html#ggplot2-grammar",
    "href": "visual.html#ggplot2-grammar",
    "title": "5  Data visualization",
    "section": "5.1 ggplot2 grammar",
    "text": "5.1 ggplot2 grammar\nggplot2, is built on the foundation of the “Grammar of Graphics.” This framework allows you to create intricate and customized plots by layering (Figure 5.1) different geometric shapes and elements. Understanding the concept of geometry and layering is essential for informative visualizations.\n\n\n\nFigure 5.1: Source: Quebec Centre for Biodiversity Science (2022), Chapter 5 in Workshop 3: Introduction to Data Visualization. source.\n\n\nBelow, we present a breakdown of different elements and common parameters for each within the Grammar of Graphics framework:\n\n5.1.1 Basic elements\nData: This refers to your dataset, organized in a tidy format, and serves as the foundation for your plot. You can utilize dplyr techniques to prepare the data for optimal plotting, usually requiring one row for each observation you intend to visualize.\nAesthetics (aes): Aesthetics are parameters that make the data visually meaningful. Here are some common aesthetics:\n\nx, y: Represent variables along the x and y axes, respectively.\ncolour: Dictates the color of the graphic elements based on data.\nfill: Specifies the interior color of the graphical element.\ngroup: Defines the group to which a graphical element belongs.\nshape: Determines the figure used for plotting a point.\nlinetype: Specifies the type of line to be used (e.g., solid, dashed).\nsize: Controls the size of elements to represent an additional dimension.\nalpha: Governs the transparency level of the graphical element.\n\nGeometric Objects (geoms): Geoms determine the type of plot to create. Here are some common geoms:\n\ngeom_point(): Used for scatterplots.\ngeom_line(): Connects points in increasing order of x values.\ngeom_path(): Connects points in the sequence of appearance.\ngeom_boxplot(): Generates box and whisker plots for categorical variables.\ngeom_bar(): Creates bar charts, typically used for categorical x-axes.\ngeom_histogram(): Produces histograms, commonly for continuous x-axes.\ngeom_violin(): Represents the kernel of data dispersion in a distribution.\ngeom_smooth(): Generates a function line based on data.\n\nFacets: Faceting helps create small multiples, allowing you to visualize subsets of your data. You can use facet_wrap() or facet_grid() for this purpose.\nStatistics: Statistics are similar to geoms, but they are computed values that summarize your data. They can show means, counts, and other statistical summaries.\nCoordinates: Coordinates determine how data is mapped onto the plot. Here are some coordinate options:\n\ncoord_cartesian: Sets limits for the plot.\ncoord_polar: Used for circular plots.\ncoord_map: Applied for various map projections.\n\nThemes: Themes define the overall visual defaults for your plot. You can use themes to specify fonts, colors, shapes, and outlines to achieve a consistent visual style.\nNext, we will demonstrate the layering grammar of ggplot2. On this example we will learn how to create a scatterplot with ggplot2 and add layers, geometries, and configurations step by step using simulated dairy cattle production data.\nStep 1: Inserting data and Aesthetics\n\n# Simulated dairy cattle production data\nset.seed(123)\ncattle_data &lt;- data.frame(\n  Year = 2000:2020,\n  Milk_Production = runif(21, min = 8000, max = 12000)) |&gt;\n  mutate(Cheese_Production = (Milk_Production * 0.3) + rnorm(21, 0, 100))\n\n# Create a ggplot object with data and aesthetics\nscatter_plot &lt;- ggplot(cattle_data, aes(x = Milk_Production, y = Cheese_Production))\nscatter_plot\n\n\n\n\nStep 2: Adding the Scatterplot (points) Geometry\n\n# Add the scatterplot geometry using geom_point\nscatter_plot &lt;- scatter_plot + geom_point()\nscatter_plot\n\n\n\n\nStep 3: Adding Labels and Title\n\n# Add labels and a title\nscatter_plot &lt;- scatter_plot +\n  labs(\n    x = \"Milk Production (Millions of Pounds)\",\n    y = \"Cheese Production (Millions of Pounds)\",\n    title = \"Scatterplot of Milk vs. Cheese Production\"\n  )\nscatter_plot\n\n\n\n\nStep 4: Applying a Minimal Theme\n\n# Apply a minimal theme\nscatter_plot &lt;- scatter_plot + theme_minimal()\n\n# Display the scatter plot\nprint(scatter_plot)"
  },
  {
    "objectID": "visual.html#exploring-geometries",
    "href": "visual.html#exploring-geometries",
    "title": "5  Data visualization",
    "section": "5.2 Exploring Geometries",
    "text": "5.2 Exploring Geometries\nIn this instance, we will present different geometric shapes and their application in ggplot2 visualizations.\n\ngeom_line() for simple Line Plot\nIn ggplot2, a line plot is often utilized in conjunction with a scatterplot, as they are frequently applied to the same dataset and serve the same visualization purpose. It is not uncommon for both types of plots to be used together.\n\n# Create a ggplot object for a scatterplot and line plot\nline_plot &lt;- ggplot(cattle_data, aes(x = Milk_Production, y = Cheese_Production)) +\n  geom_point() +  # Scatterplot (points)\n  geom_line() +   # Line plot\n  labs(\n    x = \"Milk Production (Millions of Pounds)\",\n    y = \"Cheese Production (Millions of Pounds)\",\n    title = \"Scatterplot of Milk vs. Cheese Production\"\n  ) +\n  theme_minimal()\nline_plot  # Display the combined plot\n\n\n\n\nThis type of plot is commonly employed to visualize and describe time series data, particularly in the context of climate and environmental data over time.\n\n# Create a sample time series dataset\nset.seed(123)\ndate_range &lt;- seq(as.Date(\"2023-01-01\"), as.Date(\"2023-12-01\"), by=\"1 month\")\ntemperature_data &lt;- data.frame(\n  Date = date_range,\n  Temperature = runif(length(date_range), min = 0, max = 30)\n)\n\n# Create a time series plot\nggplot(temperature_data, aes(x = Date, y = Temperature)) +\n  geom_point() + \n  geom_line() +\n  labs(\n    x = \"Date\",\n    y = \"Temperature (°C)\",\n    title = \"Monthly Temperature Time Series\"\n  ) +\n  theme_minimal()\n\n\n\n\n\n\ngeom_histogram() for Histograms\nHistograms are a commonly employed data visualization tool to illustrate the frequency distribution of a specific variable. To illustrate this, we will use the “state_milk_production” dataset, filtering it for a particular year (as it is not meaningful to examine the distribution of a variable measured over multiple years).\n\n# Filter the dataset for a specific year and select the 'milk_produced' column\nyear_to_analyze &lt;- 1980\nfiltered_data &lt;- state_milk_production |&gt;\n  filter(year == year_to_analyze) |&gt;\n  select(milk_produced)\n\n# Create a histogram\nggplot(filtered_data, aes(x = milk_produced)) +\n  geom_histogram(bins = 8, boundary=0) +\n  labs(\n    x = \"Milk Production (Pounds)\",\n    y = \"Frequency\",\n    title = paste(\"Milk Production Distribution for the Year\", year_to_analyze)\n  ) +\n  theme_minimal()\n\n\n\n\n\n\ngeom_bar() for barplots\n\n# Filter data to focus on the top 5 states with the highest milk production\ntop_states &lt;- state_milk_production |&gt;\n  group_by(state) |&gt;\n  summarise(avg_Milk = mean(milk_produced)) |&gt;\n  arrange(desc(avg_Milk)) |&gt;\n  head(5)\n\n# Create a bar plot to compare milk production in the top 5 states\nbar_plot_top_states &lt;- ggplot(top_states, aes(x = reorder(state, -avg_Milk), y = avg_Milk)) +\n  geom_bar(stat = \"identity\") +\n  labs(\n    x = \"State\",\n    y = \"Average Milk Production (Pounds)\",\n    title = \"Top 5 States with Highest Milk Production\"\n  ) +\n  theme_minimal()\n\n# Display the bar plot\nprint(bar_plot_top_states)\n\n\n\n\n\n\ngeom_smooth() for scatter plots with linear fit\nExpanding upon a dataset that includes data on milk and cheese production in various states and regions, we move beyond the confines of a basic linear plot. By introducing trendlines, we empower ourselves to delve deeper into the intricacies of the relationships between these variables.\n\n# Create a linear plot with trendlines\nlinear_plot &lt;- ggplot(cattle_data, aes(x = Milk_Production, y = Cheese_Production)) +\n  geom_point() +  # Scatterplot points\n  geom_smooth(method = \"lm\", formula = y ~ x) +  # Linear trendlines\n  labs(\n    x = \"Milk Production (Millions of Pounds)\",\n    y = \"Cheese Production (Millions of Pounds)\",\n    title = \"Linear Relationship Between Milk and Cheese Production\") +\n  theme_minimal()\n\nlinear_plot\n\n\n\n\n\n\ngeom_boxplot() and geom_violin() for Boxplots and Violin plots\nSimilar to histograms, boxplots serve the purpose of visualizing data distributions. However, they are commonly employed when the goal is to compare these distributions among different groups.\n\n# Filter the data to include only New York and California\ndf_groups &lt;- state_milk_production |&gt;\n  filter(state %in% c(\"New York\", \"California\"))\n\n# Boxplot\nggplot(data = df_groups, \n       aes(x = state, \n           y = milk_produced)) + \n  geom_boxplot() +  # Create a boxplot\n  labs(title = \"Boxplot\") +  # Add a title\n  theme_minimal()  # Apply a minimal theme\n\n\n\n# Violin plot\nggplot(data = df_groups, \n       aes(x = state, \n           y = milk_produced)) + \n  geom_violin() +  # Create a violin plot\n  labs(title = \"Violin Plot\") +  # Add a title\n  theme_minimal()  # Apply a minimal theme\n\n\n\n\n\n\ngeom_maps() for representing maps\nMaps play a fundamental role in data visualization by providing a spatial context that aids in revealing patterns, relationships, and trends in various data sets, such as demographics, environmental factors, and resource distribution.\nIn this context, we will explore the spatial distribution of milk production across the United States.\n\n# Create a new dataframe 'df' based on the 'state_milk_production' dataset\ndf &lt;- state_milk_production |&gt; \n  # Group the data by 'state'\n  group_by(state) |&gt;\n  # Calculate the average milk production for each state\n  summarise(avg_milk = mean(milk_produced))\n\n\n# load maps library\nlibrary(maps, mapproj)\n\n\nAttaching package: 'maps'\n\n\nThe following object is masked from 'package:purrr':\n\n    map\n\nstates_map &lt;- map_data(\"state\") # get a state-level map of the US\n\n# Let's make a new column for the states name\n# that matches the column of state names in our states_map\ndf$region &lt;- tolower(df$state)\n\n# Build our map\nggplot(df, \n       aes(map_id = region)) + # the variable name to link our map and dataframe\n  geom_map(aes(fill = avg_milk), # variable we want to represent with an aesthetic\n           map = states_map) + # data frame that contains coordinates\n  expand_limits(x = states_map$long, \n                y = states_map$lat) +\n  coord_map() +  # projection \n  labs(x = \"\", y = \"\") # remove axis labels"
  },
  {
    "objectID": "visual.html#faceting-for-complex-data",
    "href": "visual.html#faceting-for-complex-data",
    "title": "5  Data visualization",
    "section": "5.3 Faceting for Complex Data",
    "text": "5.3 Faceting for Complex Data\nFacetting in ggplot2 is a powerful technique that allows you to create multiple small plots, or facets, within a single visualization. Each facet typically represents a subset of your data, making it an effective way to compare and visualize multiple aspects of your dataset simultaneously. In this example, we will explore faceting in ggplot2 and demonstrate its utility through two different scenarios.\n\nExample 1:\nIn the first example, we’ll use faceting to create a bar plot that shows the average milk production in the states of New York and California over the years 2010 to 2014. This will help us visualize how milk production varies in these two states during this time period.\n\ndf_2 &lt;- state_milk_production |&gt;\n  filter(state %in% c(\"New York\", \"California\"), between(year, 2010, 2014)) |&gt;\n  group_by(state, year) |&gt;\n  summarise(avg_milk = mean(milk_produced))\n\n`summarise()` has grouped output by 'state'. You can override using the\n`.groups` argument.\n\n# Create a faceted bar plot for milk production by state\nggplot(df_2, aes(x = state, y = avg_milk)) +\n  geom_bar(stat = \"identity\", fill = \"lightblue\") +\n  facet_wrap(~year, nrow = 1) +  # Facet by year with one row\n  labs(\n    x = \"State\",\n    y = \"Milk Production (Pounds)\",\n    title = \"Faceted Bar Plot of Milk Production by Year\"\n  ) +\n  theme_minimal()\n\n\n\n\n\nExample 2:\nIn the second example, we’ll use facetting to create a scatterplot to compare the relationship between milk and cheese production for different regions. This will allow us to visually explore how these two variables are related in two different states.\n\n# Set the random seed for reproducibility\nset.seed(123)\n\n# Create a dataframe for cattle data with two states\ncattle_data_2 &lt;- data.frame(\n  Year = 2000:2021,\n  State = rep(c(\"California\", \"New York\"), each = 11),  # Assign two states alternately\n  Milk_Production = runif(22, min = 8000, max = 12000)  # Simulate milk production\n) |&gt;\nmutate(\n  Cheese_Production = case_when(\n    State == \"California\" ~ (Milk_Production * 0.3) + rnorm(22, 0, 100),\n    State == \"New York\" ~ (Milk_Production * 0.25) + rnorm(22, 0, 80)\n  )\n)\n\n# Create a faceted scatterplot with cattle data for milk vs. cheese production by region\nggplot(cattle_data_2, aes(x = Milk_Production, y = Cheese_Production)) +\n  geom_point(color = \"blue\") +\n  facet_wrap(~State, ncol = 2) +  # Facet by region with 2 columns\n  labs(\n    x = \"Milk Production (Pounds)\",\n    y = \"Cheese Production (Pounds)\",\n    title = \"Faceted Scatterplot of Milk vs. Cheese Production by Region\"\n  ) +\n  theme_minimal()"
  },
  {
    "objectID": "visual.html#configuring-aesthetics",
    "href": "visual.html#configuring-aesthetics",
    "title": "5  Data visualization",
    "section": "5.4 Configuring aesthetics",
    "text": "5.4 Configuring aesthetics\nNow, let’s explore the fundamental aspects of the aesthetic layer in data visualization. Aesthetics, as specified with aes() in ggplot2, enable us to distinguish between classes, groups, and data structures effectively.\nIn this section, we will examine key aesthetic properties, such as color, shape, size, labels, and transparency. These attributes function as essential tools for tailoring your visualizations to specific requirements, allowing you to craft informative, customizable plots that faithfully represent your data’s insights.\n\n\n5.4.1 Colour\n1. Groups (discrete variables)\n\nggplot(cattle_data_2, aes(x = Milk_Production, y = Cheese_Production, col = State)) +\n  geom_point() +  \n  geom_smooth(method = \"lm\", formula = y~x) + \n  labs(\n    x = \"Milk Production (Pounds)\",\n    y = \"Cheese Production (Pounds)\",\n    title = \"Scatterplot of Milk vs. Cheese Production by Region\"\n  ) +\n  theme_minimal()\n\n\n\n\n2. Gradients (continous variables)\n\nggplot(cattle_data_2, aes(x = Year, y = Cheese_Production, col = Milk_Production)) +\n  geom_point() +\n  labs(\n    x = \"Year\",\n    y = \"Cheese Production (Pounds)\",\n    title = \"Scatterplot of Milk vs. Cheese Production by Region\"\n  ) +\n  theme_minimal()\n\n\n\n\n2. Manual colors\nDiscrete variables\n\nggplot(cattle_data_2, aes(x = Milk_Production, y = Cheese_Production, col = State)) +\n  geom_point() +  \n  geom_smooth(method = \"lm\", formula = y~x) + \n  labs(\n    x = \"Milk Production (Pounds)\",\n    y = \"Cheese Production (Pounds)\",\n    title = \"Scatterplot of Milk vs. Cheese Production by Region\"\n  ) +\n  theme_minimal() +\n  scale_colour_manual(values = c(\"orange\",\"skyblue\"))\n\n\n\n\nGradient\n\nggplot(cattle_data_2, aes(x = Year, y = Cheese_Production, col = Milk_Production)) +\n  geom_point() +\n  labs(\n    x = \"Year\",\n    y = \"Cheese Production (Pounds)\",\n    title = \"Scatterplot of Milk vs. Cheese Production by Region\"\n  ) +\n  theme_minimal() +\n  scale_color_gradient(low = \"gray85\", high = \"black\")\n\n\n\n\n\n\n\n5.4.2 Shape Size and alpha\nLet’s move past colors for a moment. If we want to change how our data points look, we can use different shapes for different groups by specifying the “shape” parameter within the “aes()” layer. This is similar to what we did with colors. For instance, we can use the “species” variable to group our data points by shape.\nIf we’d like to control the size of the data points, we can use the “size” parameter in the same way. And if we want to make data points more or less transparent, we can use the “alpha” parameter. Both of these options work well when dealing with continuous data.\nShape for discrete variables\n\nggplot(cattle_data_2) +\n  geom_point(aes(x = Milk_Production, y = Cheese_Production, shape = State)) +  \n  geom_smooth(method = \"lm\", formula = y~x, aes(x = Milk_Production, y = Cheese_Production, linetype = State)) + \n  labs(\n    x = \"Milk Production (Pounds)\",\n    y = \"Cheese Production (Pounds)\",\n    title = \"Scatterplot of Milk vs. Cheese Production by Region\"\n  ) +\n  theme_minimal() \n\n\n\n\nSize and Alpha for continous\n\nggplot(cattle_data_2) +\n  geom_point(aes(x = Year, y = Cheese_Production, size = Milk_Production)) +\n  labs(\n    x = \"Year\",\n    y = \"Cheese Production (Pounds)\",\n    title = \"Scatterplot of Milk vs. Cheese Production by Region\"\n  ) +\n  theme_minimal() \n\n\n\n\nalpha\n\nggplot(cattle_data_2) +\n  geom_point(aes(x = Year, y = Cheese_Production, alpha = Milk_Production)) +\n  labs(\n    x = \"Year\",\n    y = \"Cheese Production (Pounds)\",\n    title = \"Scatterplot of Milk vs. Cheese Production by Region\"\n  ) +\n  theme_minimal() \n\n\n\n\n\n\n5.4.3 Legend and other stuffs\nNext, we’ll explore how to customize legends and make other adjustments. Specifically, we will focus on modifying legends and adding error bars and labels above barplots in ggplot2.\n\nModifying Legends:\n\nBy default, ggplot2 automatically generates legends for aesthetic mappings in your plot. You can customize legends in various ways:\n\nChange Legend Title: You can set the legend title using the labs function and specifying fill (for color) or shape as appropriate.\n\n\n+ labs(fill = \"Custom Legend Title\")\n\n\nRemove Legend: If you want to remove a legend for a specific aesthetic mapping, use guides() with override.aes.\n\n\n+ guides(fill = FALSE)\n\n\nChange Legend Labels: You can change legend labels using scale_fill_manual() or scale_shape_manual() functions.\n\n\n+ scale_color_manual(labels = c(\"A\", \"B\"))\n\nLets see an example on how to configure legends:\n\nreplace = c(\"A\" = \"California state\", \"B\" = \"New York State\")\n\nggplot(cattle_data_2, aes(x = Milk_Production, y = Cheese_Production, col = State)) +\n  geom_point() +  \n  geom_smooth(method = \"lm\", formula = y~x) + \n  labs(\n    x = \"Milk Production (Pounds)\",\n    y = \"Cheese Production (Pounds)\",\n    title = \"Scatterplot of Milk vs. Cheese Production by states\",\n    col = \"\"\n  ) +\n  theme_minimal() +\n  scale_colour_manual(values = c(\"orange\",\"skyblue\"), labels = c(\"California state\" ,\"New York state\")) \n\n\n\n\n\nAdding Error Bars:\n\nTo add error bars to a barplot, you can use the geom_errorbar() function. For example:\n\n+ geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.4)\n\nHere, lower and upper are the variables that contain the lower and upper error values for each bar.\n\nAdding Letters Above Barplots:\n\nTo add letters above barplots, you can use the geom_text() function. Make sure you have a variable that represents the letters you want to display. Here’s an example:\n\n+ geom_text(aes(label = letters), vjust = -0.5, size = 4)\n\nIn this example, letters is the variable that contains the letters to display, vjust adjusts the vertical position of the text above the bars, and size sets the text size.\nHere’s an example of how to include error bar to barplots:\n\n# Filter data to focus on the top 5 states with the highest milk production\ntop_states &lt;- state_milk_production |&gt;\n  group_by(state) |&gt;\n  summarise(avg_Milk = mean(milk_produced),\n            sd_Milk = sd(milk_produced)) |&gt;\n  mutate(lower = avg_Milk - sd_Milk, upper = avg_Milk + sd_Milk) |&gt;\n  arrange(desc(avg_Milk)) |&gt;\n  head(5)\n\n# Create a bar plot to compare milk production in the top 5 states\np &lt;- ggplot(top_states, aes(x = reorder(state, -avg_Milk), y = avg_Milk)) +\n  geom_bar(stat = \"identity\", fill = \"blue\") +\n  labs(\n    x = \"State\",\n    y = \"Average Milk Production (Pounds)\",\n    title = \"Top 5 States with Highest Milk Production\"\n  ) +\n  theme_minimal() +\n  # Add error bars\n  geom_errorbar(aes(ymin = lower, ymax = upper), width = 0.4) +\n  # Add letters above bars\n  geom_text(aes(label = c(\"a\", \"a\", \"b\", \"b\", \"b\"), y = 0), vjust = -0.5, size = 4, col = \"white\")\n\nprint(p)"
  },
  {
    "objectID": "visual.html#configuring-themes",
    "href": "visual.html#configuring-themes",
    "title": "5  Data visualization",
    "section": "5.5 Configuring themes",
    "text": "5.5 Configuring themes\nThroughout this turorial, the plots have consistently utilized the “theme_classic()” setting. This choice was made because the default gray background can sometimes make certain colors less distinct and harder to discern.\nThe ggplot2 package boasts an extensive array of theme elements, far too numerous to cover comprehensively here.\nRather than exploring the multitude of attributes contained within the “theme()” function Figure 5.2, you can initiate your theming journey with theme functions. These theme functions come equipped with a predefined set of elements to begin with. Below, you’ll find some illustrative examples:\n\n\n\nFigure 5.2: ggplot2 theme reference sheet by Isabella Benabaye source.\n\n\n\n5.5.1 Default theme\n\nggplot(cattle_data_2, aes(x = Milk_Production, y = Cheese_Production, col = State)) +\n  geom_point() +  \n  geom_smooth(method = \"lm\", formula = y~x) + \n  labs(\n    x = \"Milk Production (Pounds)\",\n    y = \"Cheese Production (Pounds)\",\n    title = \"Scatterplot of Milk vs. Cheese Production by Region\"\n  )# +\n\n\n\n  #theme_gray()\n\n\n\n5.5.2 Classic theme\n\nggplot(cattle_data_2, aes(x = Milk_Production, y = Cheese_Production, col = State)) +\n  geom_point() +  \n  geom_smooth(method = \"lm\", formula = y~x) + \n  labs(\n    x = \"Milk Production (Pounds)\",\n    y = \"Cheese Production (Pounds)\",\n    title = \"Scatterplot of Milk vs. Cheese Production by Region\"\n  ) +\n  theme_classic()\n\n\n\n\n\n\n5.5.3 Theme minimal\n\nggplot(cattle_data_2, aes(x = Milk_Production, y = Cheese_Production, col = State)) +\n  geom_point() +  \n  geom_smooth(method = \"lm\", formula = y~x) + \n  labs(\n    x = \"Milk Production (Pounds)\",\n    y = \"Cheese Production (Pounds)\",\n    title = \"Scatterplot of Milk vs. Cheese Production by Region\"\n  ) +\n  theme_minimal()\n\n\n\n\n\n\n5.5.4 Theme dark\n\nggplot(cattle_data_2, aes(x = Milk_Production, y = Cheese_Production, col = State)) +\n  geom_point() +  \n  geom_smooth(method = \"lm\", formula = y~x) + \n  labs(\n    x = \"Milk Production (Pounds)\",\n    y = \"Cheese Production (Pounds)\",\n    title = \"Scatterplot of Milk vs. Cheese Production by Region\"\n  ) +\n  theme_dark()\n\n\n\n\nA compelling choice is to establish a consistent theme that spans your entire analysis. For this, we can use the set_theme() option:\n\ntheme_set(theme_minimal()) \n\nggplot(cattle_data_2, aes(x = Milk_Production, y = Cheese_Production, col = State)) +\n  geom_point() +  \n  geom_smooth(method = \"lm\", formula = y~x) + \n  labs(\n    x = \"Milk Production (Pounds)\",\n    y = \"Cheese Production (Pounds)\",\n    title = \"Scatterplot of Milk vs. Cheese Production by Region\"\n  ) \n\n\n\n\nUsing the properties detalied in Figure 5.2 you can also set your own theme:\n\nmytheme &lt;- theme_bw() + \n           theme(plot.title = element_text(colour = \"blue\")) +\n           theme(legend.position = \"left\")\n\nggplot(cattle_data_2, aes(x = Milk_Production, y = Cheese_Production, col = State)) +\n  geom_point() +  \n  geom_smooth(method = \"lm\", formula = y~x) + \n  labs(\n    x = \"Milk Production (Pounds)\",\n    y = \"Cheese Production (Pounds)\",\n    title = \"Scatterplot of Milk vs. Cheese Production by Region\"\n  )  + mytheme \n\n\n\n\nWhile ggplot2 offers a set of default themes that are functional and clean, you can expand your design possibilities by integrating the “ggthemes” library. This additional library introduces an array of new themes that cater to specific needs and preferences, from classic and minimalistic to vibrant and distinctive.\n\n#install.packages(\"ggthemes\")\nlibrary(ggthemes)\n\n\n## excel theme\nggplot(cattle_data_2, aes(x = Milk_Production, y = Cheese_Production, col = State)) +\n  geom_point() +  \n  geom_smooth(method = \"lm\", formula = y~x) + \n  labs(\n    x = \"Milk Production (Pounds)\",\n    y = \"Cheese Production (Pounds)\",\n    title = \"Scatterplot of Milk vs. Cheese Production by Region\"\n  )  + theme_excel()\n\n\n\n\n\n## tufte theme\np_tufte = ggplot(cattle_data_2, aes(x = Milk_Production, y = Cheese_Production, col = State)) +\n  geom_point() +  \n  geom_smooth(method = \"lm\", formula = y~x) + \n  labs(\n    x = \"Milk Production (Pounds)\",\n    y = \"Cheese Production (Pounds)\",\n    title = \"Scatterplot of Milk vs. Cheese Production by Region\"\n  )  + theme_fivethirtyeight()\n\np_tufte"
  },
  {
    "objectID": "visual.html#arrange-plots",
    "href": "visual.html#arrange-plots",
    "title": "5  Data visualization",
    "section": "5.6 Arrange plots",
    "text": "5.6 Arrange plots\nSometimes is useful to combine one or more plots in one image. R provide several options to do this.\n1. Using grid.arrange()\ngrid.arrange() is a part of the gridExtra package and allows you to arrange multiple ggplot2 plots into a grid layout.\nFirst, make sure you have the gridExtra package installed. You can install it with install.packages(\"gridExtra\").\nHere’s how to use grid.arrange() with examples:\n\nlibrary(gridExtra)\n\n# Create some sample plots\nplot1 &lt;- ggplot(mtcars, aes(x = mpg, y = disp)) + geom_point()\nplot2 &lt;- ggplot(mtcars, aes(x = hp, y = wt)) + geom_point()\n\n# Arrange the plots into a 2x1 grid\ngrid.arrange(plot1, plot2, ncol = 2)\n\n\n\n\n2. Using patchwork\npatchwork is a popular package for arranging ggplot2 plots. It allows you to create complex layouts by combining and arranging plots.\nYou can install the patchwork package with install.packages(\"patchwork\").\nHere’s how to use patchwork with examples:\n\nlibrary(patchwork)\n# Combine the plots horizontally using the `+` operator\ncombined_plots &lt;- plot1 + plot2\ncombined_plots\n\n\n\n\n3. Using | for Simpler Vertical Arrangement\nYou can also arrange ggplot2 plots vertically using the | operator, making it simple and effective.\nHere’s how to use | with examples:\n\n# Arrange the plots vertically using the | operator\ncombined_plots &lt;- plot1 | plot2\ncombined_plots + plot_annotation(tag_levels = \"a\")\n\n\n\n\nIn this tutorial, we’ve covered three methods to arrange ggplot2 plots. You can choose the one that best suits your needs and preferences. These techniques will help you effectively display and compare multiple plots in your data visualization projects."
  },
  {
    "objectID": "visual.html#bonus",
    "href": "visual.html#bonus",
    "title": "5  Data visualization",
    "section": "5.7 Bonus",
    "text": "5.7 Bonus\nPie Chart\n\n# Create a data frame for dairy cattle production\ndata &lt;- data.frame(\n  Activity = c(\"Milk Production\", \"Breeding\", \"Feeding\", \"Health Care\", \"Other\"),\n  Percentage = c(50, 15, 20, 10, 5)\n)\n\n# Create a pie chart\np &lt;- ggplot(data, aes(x = \"\", y = Percentage, fill = Activity)) +\n  geom_bar(stat = \"identity\", width = 1) +\n  coord_polar(theta = \"y\") +\n  scale_fill_manual(values = c(\n    \"Milk Production\" = \"blue\",\n    \"Breeding\" = \"green\",\n    \"Feeding\" = \"red\",\n    \"Health Care\" = \"purple\",\n    \"Other\" = \"gray\"\n  )) +\n  labs(title = \"Dairy Cattle Production Activities\")\n\nprint(p)"
  },
  {
    "objectID": "visual.html#saving-plots",
    "href": "visual.html#saving-plots",
    "title": "5  Data visualization",
    "section": "5.8 Saving plots",
    "text": "5.8 Saving plots\nTo save a plot, we can employ the ggsave function. Within this function, you specify the desired filename, including the file format extension (e.g., “plot.png”). Next, you provide the name of the plot object in R, which, in this case, is “plot.png.” Additionally, you can specify the desired height and width of the saved plot, along with the units of measurement, such as inches.\n\nggsave(filename = \"plot.png\", # Name the file\n       plot = p_tufte, # Name of the plot object in R\n       height = 8.5, # Provide the desired dimensions\n       width = 11, \n       units = \"in\")"
  }
]